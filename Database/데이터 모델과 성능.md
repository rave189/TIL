<h1>데이터 모델과 성능</h1>

## 정규화

<h3>정규화</h3>

- 정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다.
- 정규화는 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법이다.
- 정규화를 수행하면 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화 할 수 있다.
- 정규화는 제1정규화부터 제5정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다.
- 정규화를 수행하지 않으면 이상현상이 발생할 수 있다.
  - 따라서 테이블을 분해해야 한다.
- 정규화된 모델은 테이블이 분해된다.
- 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복 데이터가 제거된다.



<strong>정규화 절차</strong>

| 정규화 절차 | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| 제1정규화   | - 속성의 원자성을 확보한다.<br />- 기본키를 설정한다.        |
| 제2정규화   | 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거한다. |
| 제3정규화   | - 기본키를 제외한 칼럼 간에 종속성을 제거한다.<br />- 즉, 이행 함수 종속성을 제거한다. |
| BCNF        | 기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해한다. |
| 제4정규화   | 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성을 제거한다. |
| 제5정규화   | 조인에 의해서 종속성이 발생되는 경우 분해한다.               |



<h3>함수적 종속성</h3>

<h6>제1정규화</h6>

- 기본키를 잡는 것이 제1정규화이다.



<h6>제2정규화</h6>

- 부분 함수 종속성이란, 기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생한다.

- 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략한다.

- 정규화는 함수적 종속성을 근거로 한다.
  - 함수적 종속성이란 X -> Y이면 Y는 X에 함수적으로 종속된다고 말한다.
- 함수적 종속성은 X가 변화하면 Y도 변화하는지 확인한다.
  - ex) 회원ID가 변화하면 이름도 변경된다.
    - 이런 경우 회원 ID는 기본키이고 회원 ID가 이름을 함수적으로 종속한다.
    - 회원 ID와 이름으로 새로운 테이블을 만들고 회원 ID를 기본키로 한다.
    - 이때 기존 테이블에서는 이름 칼럼만 빠지게 된다.



<h6>제3정규화</h6>

- 제3정규화는 이행 함수 종속성을 제거한다.
  - 이행 함수 종속성이란 기본키를 제외하고 칼럼 간에 종속성이 발생하는 것이다.
- 회원ID가 기본키인 테이블에서 관리점 코드와 관리점에서 종속성이 발생한 경우
  - 관리점 코드와 관리점으로 새로운 테이블을 만들고 관리점 코드를 기본키로 한다.
  - 이때 기존 테이블에서는 관리점 칼럼만 빠지게 된다.



<h6>BCNF</h6>

- BCNF는 복수의 후보키가 있고, 후보키들이 복합 속성이어야 하며, 서로 중첩되어야 한다.



## 정규화와 성능

<h3>정규화의 문제점</h3>

- 정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다.
- 정규화는 데이터 조회시에 조인을 유발하기 때문에 CPU와 메모리를 많이 사용한다.

```sql
SELECT 사원번호, 부서코드, 부서명, 이름, 전화번호, 주소
FROM 직원, 부서
WHERE 직원.부서코드 = 부서.부서코드
```

- 직원과 부서 테이블이 있을 때 두 개의 테이블을 조인한다면 Nested Loop가 발생한다.
  - Nested Loop를 사용하면 
    for(i=0; i<N; i++)
    	for(j=0; j<N; j++)
    		if(직원_부서코드[i] == 부서_부서코드[j]){ }
    와 같은 이중 for문을 사용해야 한다.
  - 이러한 구조는 데이터 양이 증가하면 비효율적이다.
  - 하지만 실제로는 인덱스와 옵티마이저가 있어 비효율이 발생하지는 않는다.
  - 하지만 조인이 부하를 일으키는 것은 분명하다.
- 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능 저하는 해결된다.



<h3>정규화를 사용한 성능 튜닝</h3>

- 조인으로 인하여 성능이 저하되는 문제를 반정규화로 해결할 수 있다.
- 반정규화는 데이터를 중복시키기 때문에 또 다른 문제점을 발생시킨다.
- 반정규화에 칼럼을 너무 많이 추가하면 한 행을 읽기 위해 여러 개의 블록을 일겅야 해 디스크 입출력이 증가해 성능이 떨어진다.
- 따라서 정규화는 입출력 데이터의 양을 줄여서 성능을 향상시킬 수 있다.



## 반정규화

<h3>반정규화</h3>

- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 조회 속도를 향상하지만 데이터 모델의 유연성은 낮아진다.



<h3>반정규화를 수행하는 경우</h3>

- 정규화에 충실하면 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
- 다량의 범위를 자주 처리해야 하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 요약/집계 정보가 자주 요구되는 경우



<strong>반정규화 절차</strong>

| 반정규화 절차     | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| 대상 조사 및 검토 | 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다. |
| 다른 방법 검토    | - 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다.<br />ex) 클러스터링, 뷰, 인덱스 튜닝, 응용 프로그램, 파티션 등을 검토한다. |
| 반정규화 수행     | 테이블, 속성, 관계 등을 반정규화 한다.                       |

- 클러스터링
  - 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법이다.
  - 조회 시에 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.



<h3>반정규화 기법</h3>

<h6>계산된 칼럼 추가</h6>

- 배치 프로그램으로 총 판매액, 평균잔고, 계좌 평가 등을 미리 계산하고, 그 결과를 특정 칼럼에 추가한다.



<h6>테이블 수직분할</h6>

- 하나의 테이블을 두 개 이상의 테이블로 분할한다.
  - 즉, 칼럼을 분할하여 새로운 테이블을 만든다.



<h6>테이블 수평분할</h6>

- 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다.



<h6>테이블 병합</h6>

- 1:1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
- 1:N 관계의 테이블을 병합하여 성능을 향상시킨다.
  - 하지만 많은 양의 데이터 중복이 발생한다.
- 슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.
  - 슈퍼 타입과 서브 타입
    - 고객 엔티티는 개인고객과 법인고객으로 분류된다.
      - 이때 고객 엔티티는 슈퍼 타입이고 개인고객과 법인 고객은 서브 타입이 된다.
      - 즉, 부모와 자식 관계가 나타난다.
    - 슈퍼 타입과 서브 타입의 관계는 베타적 관계와 포괄적 관계가 있다.
      -  베타적 관계는 고객이 개인고객이거나 법인고객인 경우를 의미한다.
      - 포괄적 관계는 고객이 개인고객일 수도 있고 법인고객이리 수도 있다는 것이다.



<strong>슈퍼 타입 및 서브 타입 변환 방법</strong>

| 변환 방법     | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| oneToOne Type | - 슈퍼 타입과 서브 타입을 개별 테이블로 도출한다.<br />- 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다. |
| Plus Type     | - 슈퍼 타입과 서브 타입 테이블로 도출한다.<br />- 조인이 발생하고 관리가 어렵다. |
| Single Type   | - 슈퍼 타입과 서브 타입을 하나의 테이블로 도출한다.<br />- 조인 성능이 좋고 관리가 편리하지만, 입출력 성능이 나쁘다. |



## 분산 데이터베이스

<h3>분산 데이터베이스</h3>

- 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 DBMS를 설치하고 여러 명의 사용자가 DBMS에 접속하여 데이터베이스를 사용하는 구조를 중앙 집중형 데이터베이스라고 한다.
- 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스를 분산 데이터베이스라고 한다.
- 분산 데이터베이스를 사용하는 고객은 시스템이 네트워크로 분산되어 있는지의 여부를 인식하지 못한다.
  - 또한, 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다.
  - 이처럼 데이터베이스는 투명성을 제공해야 한다.
- 투명성은 분산 데이터베이스에서 중요한 요소이며 투명성의 종류에는 분할, 윛, 지역사상, 중복, 장애 및 병행 투명성이 있다.



<strong>분산 데이터베이스의 투명성 종류</strong>

| 투명성           | 설명                                                         |
| ---------------- | :----------------------------------------------------------- |
| 분할 투명성      | 고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있음을 인식할 필요가 없다. |
| 위치 투명성      | - 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다.<br />- 고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 한다. |
| 지역 사상 투명성 | 지역 DBMS와 물적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능하다. |
| 중복 투명성      | 데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지된다. |
| 장애 투명성      | 데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도 데이터의 무결성은 보장된다. |
| 병행 투명성      | 여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다. |



<h3>분산 데이터베이스 설계 방식</h3>

- 분산 데이터베이스의 구축 방법에는 상향식 설계 방식과 하향식 설계 방식이 있다.

- 분산 데이터베이스를 구축하거나 운영할 때 동일한 DBMS로 분산 데이터베이스를 구축하는 것은 크게 어렵지 않다.
- 하지만 기업에 여러 종류의 DBMS가 있으면 이기종 DBMS로 연동해야 한다.
  - 이기종 DBMS로 연동하기 위해서는 데이터베이스 미들웨어(ODBC, JDBC)를 사용해야 한다.



<h6>상향식 설계 방식</h6>

- 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스를 구축한다.



<h6>하향식 설계 방식</h6>

- 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축한다.



<strong>분산 데이터베이스 장점과 단점</strong>

| 장점                                                         | 단점                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| - 데이터베이스 신뢰성과 가용성이 높다<br />- 분산 데이터베이스가 병렬 처리를 수행하기 때문에 빠른 응답이 가능하다.<br />- 분산 데이터베이스를 추가하여 시스템 용량 확장이 쉽다 | - 데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다.<br />- 보안 관리가 어렵다.<br />- 데이터 무결성 관리가 어렵다.<br />- 데이터베이스 설계가 복잡하다. |

