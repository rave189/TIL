<h1>SQL 최적화의 원리</h1>

## 옵티마이저와 실행 계획

<h3>옵티마이저(Optimizer)</h3>

- SQL 개발자가 SQL을 작성하여 실행할 때, 옵티마이저는 SQL을 어떻게 실행할 것인지를 계획하게 된다.
  - 즉, SQL 실행 계획을 수립하고 SQL을 실행한다.
- 옵티마이저는 SQL의 실행 계획을 수립하고 SQL을 실행하는 DBMS의 소프트웨어이다.
- 동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라서 성능이 달라진다.



<h3>옵티마이저의 특징</h3>

- 옵티마이저는 데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해서 예상되는 비용을 산정한다.
- 옵티마이저는 여러 개의 실행 계획 중에서 최저비용을 가지고 있는 계획을 선택해서 SQL을 실행한다.



<h3>옵티마이저의 필요성</h3>

- SQL 개발자가 작성한 SQL문을 어떻게 실행하느냐에 따라 성능이 달라진다.

- 데이터가 많은 테이블 A와 데이터가 적은 B테이블이 있을 때,

  A 테이블을 먼저 읽고 B 테이블을 읽으면 불필요하게 비교 횟수가 증가한다.

  하지만 B 테이블을 읽고 A 테이블을 읽는다면 비교 횟수를 줄일 수 있다.

- 옵티마이저는 실행 계획을 수립하는 것이며, 옵티마이저가 비효율적인 실행 계획을 선택한다면 SQL 개발자는 SQL을 개선해야 한다.

  - 옵티마이저의 실행 계획을 변경하고 싶다면 힌트(HINT)를 사용하면 된다.



<h3>옵티마이저 실행 계획 확인</h3>

- 옵티마이저는 SQL 실행 계획을 PLAN_TABLE에 저장한다.
- 가장 편리한 방법은 TOAD에서 Execution Plan Current SQL 메뉴를 클릭하면 된다.



## 옵티마이저 종류

<h3>옵티마이저의 실행 방법</h3>

- 개발자가 SQL을 실행하면 파싱을 실행해서 SQL의 문법 검사 및 구문분석을 수행한다.
- 구문분석이 완료되면 옵티마이저가 규칙 기반 혹은 비용 기반으로 실행 계획을 수립한다.
  - 옵티마이저는 기본적으로 비용 기반으로 실행 계획을 수립한다.
    - 이는 통계정보를 활용해서 최적의 실행 계획을 수립하는 것이다.
- 실행 계획 수립이 완료되면 SQL을 실행하고 완료되면 데이터를 인출한다.



<strong>옵티마이저 엔진</strong>

- Query Transformer: SQL문을 효율적으로 실행하기 위해서 옵티마이저가 변환한다.
  - SQL이 변환되어도 그 결과는 동일하다.
- Estimator: 통계정보를 사용해서 SQL 실행 비용을 계산한다.
  - 총 비용은 최적의 실행 계획을 수립하기 위해서이다.
- Plan Generator: SQL을 실행할 실행 계획을 수립한다.



<h3>옵티마이저 엔진</h3>

- 규칙 옵티마이저는 실행 계획을 수립할 때 15개의 우선순위를 기준으로 실행 계획을 수립한다.



<strong>규칙 기반 옵티마이저 엔진 우선순위</strong>

1. ROWID를 사용한 단일 행인 경우
2. 클러스터 조인에 의한 단일 행인 경우
3. 유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일 행인 경우
4. 유일하거나 기본키에 의한 단일 행인 경우
5. 클러스터 조인인 경우
6. 해시 클러스터 조인인 경우
7. 인덱스 클러스터 키인 경우
8. 복합 칼럼 인덱스인 경우
9. 단일 칼럼 인덱스인 경우
10. 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우
11. 인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우
12. 정렬-병합 조인인 경우
13. 인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우
14. 인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우
15. 전체 테이블을 스캔(FULL TABLE SCAN)하는 경우



<h3>비용 기반 옵티마이저</h3>

- 비용 기반 옵티마이저는 오브젝트 통계 및 시스템 통계를 사용해서 총 비용을 계산한다.
- 총 비용이라는 것은 SQL문을 실행하기 위해서 예상되는 소요시간 혹은 자원의 사용량을 의미한다.
- 총 비용이 적은 쪽으로 실행 계획을 수립한다.
  - 단, 비용 기반 옵티마이저에서 통계정보가 부적절한 경우 성능 저하가 발생할 수 있다.



## 인덱스

<h3>인덱스</h3>

- 인덱스는 데이터를 빠르게 검색할 수 있는 방법을 제공한다.
- 인덱스는 인덱스 키로 정렬되어 있기 때문에 원하는 데이터를 빠르게 조회한다.
- 인덱스는 오름차순 및 내림차순 탐색이 가능하다.
- 하나의 테이블에 여러 인덱스를 생성할 수 있고, 하나의 인덱스는 여러 개의 칼럼으로 구성될 수 있다.
- 테이블을 생성할 때 기본키는 자동으로 인덱스가 만들어지고 인덱스의 이름은 SYSXXXX이다.
- 인덱스의 구조는 Root Block, Branch Block, Leaf Block으로 구성되고, Root Block은 인덱스 트리에서 가장 상위의 노드이고 Branch Block은 다음 단계의 주소를 가지는 포인터로 되어 있다.
- Leaf Block은 인덱스 키와 ROWID로 구성되고 인덱스 키는 정렬되어서 저장되어 있다.
  - Leaf Block은 Double Linked List 형태로 되어 있어 양방향 탐색이 가능하다.
- Leaf Block에서 인덱스 키를 읽으면 ROWID를 사용해서 EMP 테이블의 행을 직접 읽을 수 있다.



<h3>인덱스 생성</h3>

- 인덱스 생성은 'CREATE INDEX'문을 사용해서 생성할 수 있다.
- 인덱스를 생성할 때는 한 개 이상의 칼럼을 사용해서 생성할 수 있다.
- 인덱스 키는 기본적으로 오름차순으로 정렬하고 'DESC'구를 포함하여 내림차순으로 정렬할 수 있다.



<h3>인덱스 스캔</h3>

- 인덱스 유일 스캔(Index Unique SCAN)
  - 인덱스 유일 스캔은 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생된다.
- 인덱스 범위 스캔(Index Range SCAN)
  - 인덱스 범위 스캔은 SELECT문에서 특정 범위를 조회하는 WHERE문을 사용할 경우 발생한다.
  - 인덱스 범위 스캔은 인덱스의 Leaf Block의 특정 범위를 스캔한 것이다.
  - ex) Like, Between
- 인덱스 전체 스캔(Index Full SCAN)
  - 인덱스 전체 스캔은 인덱스에서 검색되는 인덱스 키가 많은 경우에 Leaf Block의 처음부터 끝까지 전체를 읽어 들인다.



## 실행 계획

```sql
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND EMP.DEPTNO = 10;
```



쿼리 실행 계획

1. DEPT 테이블의 인덱스 유일 스캔을 한다.
2. DEPT 테이블 ROWID를 사용해서 조회한다.
3. EMP 테이블을 전체 스캔 한다.
4. DEPT 테이블과 EMP 테이블을 Nested Loop 방식의 조인을 해서 최종 결과를 만들어 낸다.

- Nested Loop 방식의 조인은 DEPT 테이블에서 먼저 데이터를 찾고 그다음 EMP 테이블을 찾는 것을 의미한다. 
  - 이러한 것을 Random Access라고 한다.

- 위와 같은 실행 계획에서 먼저 조회되는 테이블을 Outer Table이라고 하고 그 다음 조회되는 테이블을 Inner Table이라고 한다.



## 옵티마이저 조인

<h3>Nested Loop 조인</h3>

- Nested Loop 조인은 하나의 테이블에서 데이터를 먼저 찾고 그다음 테이블을 조인하는 방식으로 실행된다.
- Nested Loop 조인에서 먼저 조회되는 테이블을 외부 테이블(Outer Table)이라고 하고 그다음 조회되는 테이블을 내부 테이블(Inner Table)이라고 한다.
- Nested Loop 조인에서는 외부 테이블(선행 테이블)의 크기가 작은 것을 먼저 찾는 것이 중요하다.
  - 작은 테이블부터 찾아야 스캔되는 범위를 줄일 수 있기 때문이다.
- Nested Loop 조인은 Random Access가 발생하는데 Random Access가 많이 발생하면 성능 지연이 발생한다. 
  - 따라서 Random Access를 줄이는 것이 성능을 향상시킬 수 있다.



<h3>Sort Merge 조인</h3>

- Sort Merge 조인은 두 개의 테이블을 SORT_AREA라는 메모리 공간에 모두 로딩하고 SORT를 수행한다.
- 두 개의 테이블에서 SORT가 완료되면 두 개의 테이블을 병합한다.
- Sort Merge 조인은 정렬이 발생하기 때문에 데이터양이 많아지면 성능이 떨어지게 된다.
- 정렬 데이터양이 너무 많으면 정렬은 임시 영역에서 수행된다.
  - 임시 영역은 디스크에 있기 때문에 성능이 급격히 떨어진다.



<h3>Hash 조인</h3>

- Hash 조인은 두 개의 테이블 중에서 작은 테이블을 HASH 메모리에 로딩하고 두 개의 테이블의 조인 키를 사용해서 해시 테이블을 생성한다.
- Hash 조인은 해시 함수를 사용해서 주소를 계산하고 해당 주소를 사용해서 테이블을 조인하기 때문에 CPU 연산을 많이 한다.
- 특히 Hash 조인 시에는 선행 테이블이 충분히 메모리에 로디오디는 크기여야 한다.



